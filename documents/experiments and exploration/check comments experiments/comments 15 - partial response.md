```json
{
  "fileContent": "import React, { useState, useEffect } from \"react\";\nimport { useGithubContext } from \"../context/useGithubContext\";\nimport { githubGetCodeApi } from \"../api/apiconfigs\";\nimport {\n  defaultGenerationConfig,\n  generateContentWithConfig,\n  generateWithSystemInstructionAndConfig,\n  generateWithSystemInstructionConfigAndTools,\n  generateWithTools,\n  PullRequestArgs,\n} from \"../geminiAPI/geminiAPI\";\nimport { Slider } from \"@mui/material\";\n\nconst CodeEdit: React.FC = () => {\n  // Accessing context values using the useGithubContext hook\n  const {\n    username,\n    repository,\n    token,\n    selectedItems,\n    results,\n    resultsFromRepo,\n    cache,\n    setCache,\n    repoFileContentArray,\n    setRepoFileContentArray,\n    geminiApiKey,\n  } = useGithubContext();\n\n  // State variables for managing loading states, errors, output, and configurations\n  const [loading, setLoading] = useState(false);\n  const [loadingMessage, setLoadingMessage] = useState<string>(\"\");\n  const [error, setError] = useState<string | null>(null);\n  const [output, setOutput] = useState<string>(\n    cache.get(\"generatedContent\") || \"\"\n  );\n  const [modelTemperature, setModelTemperature] = useState<number>(0);\n  const [autoPullRequest, setAutoPullRequest] = useState<boolean>(false);\n  const [selectedFilePath, setSelectedFilePath] = useState<string>(\"\");\n  const [minimizedCache, setMinimizedCache] = useState<boolean>(false);\n  // Function to toggle the minimized state of the cache display\n  const toggleMinimizedCache = () => {\n    setMinimizedCache(!minimizedCache);\n  };\n  // Function to clear the generated content from the cache and reset the output\n  const clearGenContent = () => {\n    cache.delete(\"generatedContent\");\n    cache.delete(\"finalPrompt\");\n    setOutput(\"\");\n    console.log(\"Cache size: \", cache.size);\n  };\n  // Function to clear the repository content from the cache and reset the file content array\n  const clearRepoContent = () => {\n    cache.delete(\"repoFileContents\");\n    setRepoFileContentArray([]);\n    setOutput(\"\");\n    console.log(\"Cache: \", cache);\n  };\n\n  // Function to download the generated output as a file\n  const downloadOutput = (\n    content: string,\n    filetype: string,\n    filename: string\n  ) => {\n    const blob = new Blob([content], { type: filetype });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = filename;\n    link.click();\n    URL.revokeObjectURL(url);\n  };\n\n  // Function to strip code fences from the generated content\n  const stripCodeFences = (content: string): string => {\n    return content\n      .replace(/^```[\\w]*\\s*/i, \"\") // Remove opening fence and optional language tag\n      .replace(/```$/, \"\") // Remove closing fence\n      .trim();\n  };\n\n  // Function to validate the initial state before generating content\n  const validateInitialState = (): boolean => {\n    if (!repository) {\n      setError(\"No repository selected. Please select a repo first.\");\n      return false;\n    }\n    if (results && results.length == 0) {\n      setError(\n        \"No results found. Please attempt a search to see what is in your repo first.\"\n      );\n      return false;\n    }\n    return true;\n  };\n\n  // Function to check the cache for existing content\n  const checkCache = (): {\n    repoFileContents: string;\n    finalPrompt: string;\n    generatedContent: string;\n  } => {\n    return {\n      repoFileContents: cache.get(\"repoFileContents\") || \"\",\n      finalPrompt: cache.get(\"finalPrompt\") || \"\",\n      generatedContent: cache.get(\"generatedContent\") || \"\",\n    };\n  };\n\n  // Function to fetch the file contents from GitHub\n  const fetchFileContents = async (\n    items: any[]\n  ): Promise<{ // Define the return type of the function\n    fileContents: string;\n    fileContentArray: string[];\n    errmsg: string;\n  }> => {\n    var fileContents = \"\";\n    var fileContentArray: string[] = [];\n    var errmsg = \"\";\n    for (const item of results) {\n      try {\n        const response = await githubGetCodeApi.get(\n          `/${item.repository.full_name}/contents/${item.path}`,\n          {\n            headers: {\n              Authorization: `Bearer ${token}`,\n            },\n          }\n        );\n        const fileContent = atob(response.data.content);\n        fileContents += item.path + \"\\n\" + fileContent + \"\\n\\n\";\n        fileContentArray.push(item.path + \"\\n\" + fileContent);\n      } catch (error) {\n        console.error(`Error fetching file content for ${item.path}: ${error}`);\n        errmsg += item.path + \"; \";\n      }\n    }\n\n    console.log(\"fileContentArray fetched: \", fileContentArray);\n    return { fileContents, fileContentArray, errmsg };\n  };\n\n  // Function to generate a README file\n  const generateREADME = async () => {\n    setLoading(true);\n    setLoadingMessage(\"Validating initial state...\");\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n    setLoadingMessage(\"Checking cache...\");\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      setLoadingMessage(\"Fetching file contents...\");\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n        return;\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      setLoadingMessage(\"Preparing final prompt...\");\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (!finalPrompt) {\n      setError(\"No content to generate README for.\");\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n\n    if (generatedContent == \"\") {\n      setLoadingMessage(\"Generating README...\");\n      if (autoPullRequest) {\n        console.log(\"Auto pull request enabled.\");\n        const systemInstruction = `You are an API agent. Your response will be consumed directly by code and parsed as a JSON object. Do not format your JSON output in markdown fence blocks. Do not include any explanations. Do not use code fences like \\`\\`\\`json. Just return a raw JSON object.\\nSubmit a pull request for a suggested README file for my code repository ${repository}. You do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        console.log(\n          \"repoFileContentArray before gen ai: \",\n          repoFileContentArray\n        );\n        const genWithToolsResponse =\n          await generateWithSystemInstructionConfigAndTools(\n            geminiApiKey,\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          );\n\n        console.log(\"genWithToolsResponse: \", genWithToolsResponse);\n        console.log(\"genWithToolsResponse text: \", genWithToolsResponse.text);\n        var pullRequestResult = \"Error submitting pull request\";\n\n        setLoadingMessage(\"Submitting pull request...\");\n        // this is the built in function call from the api, usually dont work if context is too large\n        if (genWithToolsResponse.functionCalls) {\n          console.log(\"function calls: \", genWithToolsResponse.functionCalls);\n          const tool_call = genWithToolsResponse.functionCalls[0];\n          if (tool_call.name === \"submit_pull_request\" && tool_call.args) {\n            pullRequestResult = await submitPullRequest(\n              [\n                {\n                  filePath: tool_call.args.filePath as string,\n                  fileContent: tool_call.args.fileContent as string,\n                },\n              ],\n              tool_call.args.commitMessage as string,\n              tool_call.args.branchName as string,\n              tool_call.args.pullRequestTitle as string,\n              tool_call.args.pullRequestBody as string\n            );\n          }\n        } else {\n          if (genWithToolsResponse.text && genWithToolsResponse.text != \"\") {\n            // try to parse the response as a json object (specified in the system instruction) and call the function\n            try {\n              const parsedResponse: PullRequestArgs = JSON.parse(\n                genWithToolsResponse.text\n              );\n              console.log(\"parsed response: \", parsedResponse);\n              pullRequestResult = await submitPullRequest(\n                [\n                  {\n                    filePath: parsedResponse.filePath,\n                    fileContent: parsedResponse.fileContent,\n                  },\n                ],\n                parsedResponse.commitMessage,\n                parsedResponse.branchName,\n                parsedResponse.pullRequestTitle,\n                parsedResponse.pullRequestBody\n              );\n              generatedContent =\n                pullRequestResult + \"\\n\" + genWithToolsResponse.text;\n            } catch (error) {\n              try {\n                // try again after cleaning since the ai keeps wrapping in these tags\n                const cleanJson = genWithToolsResponse.text\n                  .replace(/```json|```$/g, \"\")\n                  .trim();\n                const parsedResponse: PullRequestArgs = JSON.parse(cleanJson);\n                console.log(\"parsed response after cleaning: \", parsedResponse);\n                pullRequestResult = await submitPullRequest(\n                  [\n                    {\n                      filePath: parsedResponse.filePath,\n                      fileContent: parsedResponse.fileContent,\n                    },\n                  ],\n                  parsedResponse.commitMessage,\n                  parsedResponse.branchName,\n                  parsedResponse.pullRequestTitle,\n                  parsedResponse.pullRequestBody\n                );\n                console.log(pullRequestResult);\n                generatedContent =\n                  pullRequestResult + \"\\n\" + genWithToolsResponse.text;\n              } catch (error) {\n                console.error(\"Error parsing response: \", error);\n              }\n            }\n          } else {\n            generatedContent = genWithToolsResponse.text || \"\";\n          }\n        }\n      } else {\n        // if auto pull request is not enabled, just generate the readme and put it on the UI\n        const systemInstruction = `Generate a README for the code repository ${repository}, only return the contents of the README.\\nFormat the README using standard Markdown syntax for text styling. Avoid using code blocks unless displaying code.\\nYou do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        generatedContent =\n          (await generateWithSystemInstructionAndConfig(\n            geminiApiKey,\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          )) || \"\";\n      }\n    }\n\n    cache.set(\"generatedContent\", generatedContent);\n    setOutput(generatedContent);\n    setLoading(false);\n    setLoadingMessage(\"\");\n  };\n\n  // Function to generate documentation for the repository\n  const generateDocumentation = async () => {\n    setLoading(true);\n    setLoadingMessage(\"Validating initial state...\");\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n\n    setLoadingMessage(\"Checking cache...\");\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      setLoadingMessage(\"Fetching file contents...\");\n      const { fileContents, errmsg } = await fetchFileContents(results);\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n        return;\n      }\n      repoFileContents = fileContents;\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    if (finalPrompt == \"\") {\n      setLoadingMessage(\"Preparing final prompt...\");\n      finalPrompt = `Generate documentation for the repository ${repository} with the following code. For conciseness, you do not need to include the code directly in the documentation, you may chose to include the file path if required. Write the documentation in a way that is easy to understand for a beginner. The documentation should use markdown styling, do not wrap your entire output in markdown tags. The documentation should be split into two sections: how-to guides and reference guides. Try to be detailed for the reference guide. Also include notes for anything the reader should look out for\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    console.log(finalPrompt);\n    if (!finalPrompt) {\n      setError(\"No content to generate documentation for.\");\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n\n    var generatedContent = \"\";\n    if (!cache.has(\"generatedContent\")) {\n      setLoadingMessage(\"Generating documentation...\");\n      generatedContent =\n        (await generateContentWithConfig(geminiApiKey, finalPrompt, {\n          temperature: modelTemperature,\n        })) || \"Error generating content\";\n      cache.set(\"generatedContent\", generatedContent);\n    } else {\n      generatedContent = cache.get(\"generatedContent\") || \"\";\n    }\n\n    setOutput(generatedContent);\n    setLoading(false);\n    setLoadingMessage(\"\");\n  };\n\n  // Function to generate comments for selected files and submit a pull request\n  const generateCommentsAndSendPullRequest = async (selectedFiles: any[]) => {\n    setLoading(true);\n    setLoadingMessage(\"Validating initial state...\");\n    setError(null);\n\n    if (!validateInitialState()) {\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n    setLoadingMessage(\"Checking cache...\");\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      setLoadingMessage(\"Fetching file contents...\");\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n        return;\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      setLoadingMessage(\"Preparing final prompt...\");\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (generatedContent != \"\") {\n      setLoading(false);\n      setLoadingMessage(\"\");\n    }\n\n    setLoadingMessage(\"Validating input files...\");\n    if (\n      !selectedFiles ||\n      !Array.isArray(selectedFiles) ||\n      selectedFiles.length == 0\n    ) {\n      setError(\"No files selected. Please select some files first.\");\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n\n    setLoadingMessage(\"Processing selected files...\");\n    const outputs: { filePath: string; fileContent: string }[] = []; // Array to store outputs for each file\n\n    for (const file of selectedFiles) {\n      setLoadingMessage(`Processing ${file.path}...`);\n      try {\n        const systemInstruction = `Help me make sure that the code ${file.path} is well documented. Give me the full updated file only if comments in the file need changes. Return \\\"none\\\" if no changes are needed. Your output will be parsed by code and will not be seen by users. Do not wrap your output in markdown tags.`;\n\n        const generatedContent =\n          (await generateWithSystemInstructionAndConfig(\n            geminiApiKey,\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          )) || \"Error generating content\";\n\n        if (\n          generatedContent !== \"none\" &&\n          generatedContent !== \"\" &&\n          generatedContent !== \"Error generating content\"\n        ) {\n          const cleanedContent = stripCodeFences(generatedContent);\n          if (cleanedContent !== \"\") {\n            outputs.push({\n              filePath: file.path,\n              fileContent: cleanedContent,\n            });\n          } else {\n            console.log(\n              `No changes needed after removing code fences for ${file.path}`\n            );\n          }\n        } else {\n          console.log(`No generated content for ${file.path}`);\n        }\n      } catch (error) {\n        console.error(`Error processing file ${file.path}:`, error);\n        outputs.push({\n          filePath: file.path,\n          fileContent: \"Error generating content\",\n        });\n      }\n    }\n\n    if (outputs.length > 0) {\n      const pullRequestResult = submitPullRequest(\n        outputs,\n        \"Generated comments\",\n        \"generated-comments\",\n        \"Generated comments\",\n        \"These are the generated comments from github search saas\"\n      );\n\n      const outputArray: string = JSON.stringify(outputs, null, 2);\n      const finalOutput: string = `Pull request result: ${pullRequestResult}\\n\\nGenerated comments:\\n${outputArray}`;\n      cache.set(\"generatedContent\", finalOutput);\n      setOutput(finalOutput);\n    } else {\n      setOutput(\"No output generated.\");\n    }\n\n    console.log(\"Generated outputs:\", outputs);\n    setLoading(false);\n    setLoadingMessage(\"\");\n  };\n\n  // Function to check the comments in a selected file\n  const checkComments = async (selectedFilePath: string) => {\n    setLoading(true);\n    setLoadingMessage(\"Validating initial state...\");\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n    setLoadingMessage(\"Checking cache...\");\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      setLoadingMessage(\"Fetching file contents...\");\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n        return;\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      setLoadingMessage(\"Preparing final prompt...\");\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (generatedContent == \"\") {\n      setLoadingMessage(\"Validating comments...\");\n      const systemInstruction = `Help me check the comments written for the code ${selectedFilePath} and make sure they are accurate. Give me the full updated file only if comments in the file needs changes. Otherwise just let me know that the comments are accurate.`;\n\n      generatedContent =\n        (await generateWithSystemInstructionAndConfig(\n          geminiApiKey,\n          systemInstruction,\n          finalPrompt,\n          {\n            temperature: modelTemperature,\n          }\n        )) || \"Error generating content\";\n\n      console.log(\"generatedContent: \", generatedContent);\n      cache.set(\"generatedContent\", generatedContent);\n      setOutput(generatedContent);\n    }\n\n    setLoading(false);\n    setLoadingMessage(\"\");\n  };\n\n  // Function to check if a selected file is well documented\n  const wellDocumented = async (selectedFilePath: string) => {\n    setLoading(true);\n    setLoadingMessage(\"Validating initial state...\");\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      setLoadingMessage(\"\");\n      return;\n    }\n    setLoadingMessage(\"Checking cache...\");\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      setLoadingMessage(\"Fetching file contents...\");\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n        return;\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      setLoadingMessage(\"Preparing final prompt...\");\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (generatedContent == \"\") {\n      setLoadingMessage(\"Validating documentation...\");\n      const systemInstruction = `Help me make sure that the code ${selectedFilePath} is well documented. Give me the full updated file only if comments in the file needs changes.`;\n\n      generatedContent =\n        (await generateWithSystemInstructionAndConfig(\n          geminiApiKey,\n          systemInstruction,\n          finalPrompt,\n          {\n            temperature: modelTemperature,\n          }\n        )) || \"Error generating content\";\n\n      console.log(\"generatedContent: \", generatedContent);\n      cache.set(\"generatedContent\", generatedContent);\n      setOutput(generatedContent);\n    }\n\n    setLoading(false);\n    setLoadingMessage(\"\");\n  };\n\n  // Function to submit a pull request to GitHub\n  const submitPullRequest = async (\n    files: { filePath: string; fileContent: string }[],\n    commitMessage: string,\n    branchName: string,\n    pullRequestTitle: string,\n    pullRequestBody: string\n  ): Promise<string> => {\n    console.log(\"Submitting pull request...\");\n    if (!files || files.length === 0) {\n      if (output === \"\") {\n        setError(\"No content to submit for pull request.\");\n        return \"No content to submit for pull request.\";\n      }\n      files = [{ filePath: \"README.md\", fileContent: output }];\n    }\n    if (files.some((file) => !file.filePath || !file.fileContent)) {\n      console.log(\"File paths or file contents are empty.\");\n      setError(\"File paths or file contents are empty.\");\n      return \"File paths or file contents are empty.\";\n    }\n    if (commitMessage === \"\") {\n      console.log(\"Default commit message used as no commit message provided.\");\n      setError(\"Default commit message used as no commit message provided.\");\n      commitMessage = \"Generated README from github search saas\";\n    }\n    branchName = branchName.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n    console.log(\"branch name sanitized: \", branchName);\n    if (!branchName || branchName === \"\") {\n      console.log(\n        \"Default branch name used as no branch name after sanitizing.\"\n      );\n      setError(\"Default branch name used as no branch name after sanitizing.\");\n      branchName = \"generated-readme\";\n    }\n    if (!pullRequestTitle || pullRequestTitle === \"\") {\n      console.log(\n        \"Default pull request title used as no pull request title provided.\"\n      );\n      setError(\n        \"Default pull request title used as no pull request title provided.\"\n      );\n      pullRequestTitle = \"Generated README\";\n    }\n    if (!pullRequestBody || pullRequestBody === \"\") {\n      console.log(\n        \"Default pull request body used as no pull request body provided.\"\n      );\n      setError(\n        \"Default pull request body used as no pull request body provided.\"\n      );\n      pullRequestBody = \"This is a generated README from github search saas\";\n    }\n\n    try {\n      // get default branch\n      const defaultBranchResponse = await githubGetCodeApi.get(\n        `/${username}/${repository}`,\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      const defaultBranch = defaultBranchResponse.data.default_branch;\n      console.log(\"default branch of repo: \", defaultBranch);\n\n      // get latest commit and tree\n      const commitAndTreeResponse = await githubGetCodeApi.get(\n        `/${username}/${repository}/branches/${defaultBranch}`,\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      const oldCommit = commitAndTreeResponse.data.commit.sha;\n      const oldTree = commitAndTreeResponse.data.commit.commit.tree.sha;\n      console.log(\"previous commit and tree: \", oldCommit, oldTree);\n\n      let newTree = oldTree;\n      let newCommit = oldCommit;\n\n      // loop through files to create commits\n      for (const { filePath, fileContent } of files) {\n        // Create new tree with new file\n        const newTreeResponse = await githubGetCodeApi.post(\n          `/${username}/${repository}/git/trees`,\n          {\n            base_tree: newTree,\n            tree: [\n              {\n                path: filePath,\n                mode: \"100644\",\n                type: \"blob\",\n                content: fileContent,\n              },\n            ],\n          },\n          {\n            headers: {\n              Authorization: `Bearer ${token}`,\n            },\n          }\n        );\n        newTree = newTreeResponse.data.sha;\n      }\n      // Create new commit object\n      const newCommitResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/git/commits`,\n        {\n          message: commitMessage,\n          tree: newTree,\n          parents: [newCommit],\n        },\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      newCommit = newCommitResponse.data.sha;\n      console.log(\"new commit: \", newCommit);\n\n      // Create new reference (branch) for the commit\n      const newBranchName = branchName + Date.now();\n      const newReferenceResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/git/refs`,\n        {\n          ref: `refs/heads/${newBranchName}`,\n          sha: newCommit,\n        },\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      console.log(\"new reference: \", newReferenceResponse);\n\n      // create pull request\n      const pullRequestResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/pulls`,\n        {\n          title: pullRequestTitle,\n          body: pullRequestBody,\n          head: newBranchName,\n          base: defaultBranch,\n        },\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      console.log(\"pull request response: \", pullRequestResponse);\n      return \"Pull request submitted successfully!\";\n    } catch (error) {\n      console.error(\"Error submitting pull request: \", error);\n      return \"Error submitting pull request: \" + error;\n    }\n  };\n\n  return (\n    <div className=\"p-4 border-gray-500 border-2 rounded-lg flex-grow\">\n      <div className=\"flex flex-col gap-4 items-start\">\n        <h2 className=\"text-2xl\">Extra functions</h2>\n        {resultsFromRepo != repository && (\n          <p className=\"text-xl font-bold text-red-500\">\n            Files loaded from search may not be up to date, please refresh the\n            search in order to use this feature\n          </p>\n        )}\n        <div className=\"flex gap-4 w-full\">\n          <p className=\"text-lg text-nowrap\">\n            Model Temperature (how much creativity/variation in the output):\n          </p>\n          <div className=\"w-1/3\">\n            <Slider\n              aria-label=\"Temperature\"\n              size=\"small\"\n              defaultValue={0}\n              min={0}\n              max={1}\n              step={0.1}\n              marks\n              valueLabelDisplay=\"auto\"\n              onChange={(_, value) => {\n                setModelTemperature(value.valueOf() as number);\n              }}\n            />\n          </div>\n          <p>{modelTemperature}</p>\n        </div>\n        <div className=\"flex gap-4 w-full\">\n          <div>\n            <p className=\"text-lg\">Username: {username || \"None selected\"}</p>\n            <div>\n              <div className=\"flex flex-col gap-4 mb-2\">\n                <p className=\"text-lg\">\n                  Repository: {repository || \"None selected\"}\n                </p>\n\n                <button\n                  onClick={generateDocumentation}\n                  className=\"w-fit !bg-blue-900\"\n                >\n                  Generate Documentation\n                </button>\n\n                <div className=\"flex gap-4 items-center\">\n                  <button\n                    onClick={generateREADME}\n                    className=\"w-fit !bg-gray-600\"\n                  >\n                    Generate README\n                  </button>\n                  <p>Auto Submit Pull Request?</p>\n                  <input\n                    type=\"checkbox\"\n                    checked={autoPullRequest}\n                    onChange={(e) => setAutoPullRequest(e.target.checked)}\n                  />\n                </div>\n\n                <button\n                  onClick={() =>\n                    generateCommentsAndSendPullRequest(selectedItems)\n                  }\n                  className=\"w-fit !bg-green-900\"\n                >\n                  Generate Comments for all selected files and submit PR\n                </button>\n              </div>\n            </div>\n          </div>\n          <div className=\"ml-auto flex flex-col gap-2 w-1/3\">\n            <h3 className=\"text-lg gap-4 flex items-center\">\n              Processing Cache (makes generation faster){" "}\n              <button\n                onClick={toggleMinimizedCache}\n                className=\"!p-1 !bg-blue-900\"\n              >\n                {minimizedCache ? \"Show\" : \"Hide\"}\n              </button>\n            </h3>\n            <div\n              className={`flex flex-col gap-2 ${\n                minimizedCache ? \"hidden\" : \"\"\n              }`}\n            >\n              {cache.has(\"repoFileContents\") ? (\n                <div className=\"flex items-center gap-4\">\n                  <p className=\"text-green-500 max-w-1/2\">\n                    Repository File Contents Cached{" "}\n                    {repoFileContentArray.length} from {resultsFromRepo}\n                  </p>\n                  <button onClick={clearRepoContent}>\n                    Clear File Content cache\n                  </button>\n                </div>\n              ) : (\n                <p className=\"text-red-500 font-bold\">\n                  Repository File Contents not Cached\n                </p>\n              )}\n              {cache.has(\"generatedContent\") ? (\n                <div className=\"flex  items-center gap-4\">\n                  <p className=\"text-green-500\">\n                    AI Output Cached\n                    <br />\n                    Clear this to regenerate output\n                  </p>\n