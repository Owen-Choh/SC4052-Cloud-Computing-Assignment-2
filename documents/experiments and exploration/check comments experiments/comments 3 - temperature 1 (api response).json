{
    "candidates": [
        {
            "content": {
                "parts": [
                    {
                        "text": "Okay, I've reviewed the code and comments in the `SC4052-Cloud-Computing-Assignment-2` repository. I've identified the following areas where the comments could be improved for accuracy and clarity.\n\n**File: github-search-saas/src/components/CodeEdit.tsx**\n\n```typescript\nimport React, { useState, useEffect } from \"react\";\nimport { useGithubContext } from \"../context/useGithubContext\";\nimport { githubGetCodeApi } from \"../api/apiconfigs\";\nimport {\n  defaultGenerationConfig,\n  generateContentWithConfig,\n  generateWithSystemInstructionAndConfig,\n  generateWithSystemInstructionConfigAndTools,\n  generateWithTools,\n  PullRequestArgs,\n} from \"../geminiAPI/geminiAPI\";\nimport { Slider } from \"@mui/material\";\n\nconst CodeEdit: React.FC = () =\u003e {\n  const {\n    username,\n    repository,\n    selectedItems,\n    results,\n    cache,\n    setCache,\n    repoFileContentArray,\n    setRepoFileContentArray,\n  } = useGithubContext();\n\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState\u003cstring | null\u003e(null);\n  const [output, setOutput] = useState\u003cstring\u003e(\n    cache.get(\"generatedContent\") || \"\"\n  );\n  const [modelTemperature, setModelTemperature] = useState\u003cnumber\u003e(0);\n  const [autoPullRequest, setAutoPullRequest] = useState\u003cboolean\u003e(false);\n\n  const clearGenContent = () =\u003e {\n    cache.delete(\"generatedContent\");\n    cache.delete(\"finalPrompt\");\n    setOutput(\"\");\n    console.log(\"Cache size: \", cache.size);\n  };\n  const clearRepoContent = () =\u003e {\n    cache.delete(\"repoFileContents\");\n    setRepoFileContentArray([]);\n    setOutput(\"\");\n    console.log(\"Cache: \", cache);\n  };\n\n  const downloadOutput = (\n    content: string,\n    filetype: string,\n    filename: string\n  ) =\u003e {\n    const blob = new Blob([content], { type: filetype });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = filename;\n    link.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const validateInitialState = (): boolean =\u003e {\n    if (!repository) {\n      setError(\"No repository selected. Please select a repo first.\");\n      return false;\n    }\n    if (results && results.length == 0) {\n      setError(\n        \"No results found. Please attempt a search to see what is in your repo first.\"\n      );\n      return false;\n    }\n    return true;\n  };\n\n  const checkCache = (): {\n    repoFileContents: string;\n    finalPrompt: string;\n    generatedContent: string;\n  } =\u003e {\n    return {\n      repoFileContents: cache.get(\"repoFileContents\") || \"\",\n      finalPrompt: cache.get(\"finalPrompt\") || \"\",\n      generatedContent: cache.get(\"generatedContent\") || \"\",\n    };\n  };\n\n  const fetchFileContents = async (\n    items: any[]\n  ): Promise\u003c{\n    fileContents: string;\n    fileContentArray: string[];\n    errmsg: string;\n  }\u003e =\u003e {\n    var fileContents = \"\";\n    var fileContentArray: string[] = [];\n    var errmsg = \"\";\n    for (const item of results) {\n      try {\n        const response = await githubGetCodeApi.get(\n          `/${item.repository.full_name}/contents/${item.path}`\n        );\n        const fileContent = atob(response.data.content);\n        fileContents += item.path + \"\\n\" + fileContent + \"\\n\\n\";\n        fileContentArray.push(item.path + \"\\n\" + fileContent);\n      } catch (error) {\n        console.error(`Error fetching file content for ${item.path}: ${error}`);\n        errmsg += item.path + \"; \";\n      }\n    }\n\n    console.log(\"fileContentArray fetched: \", fileContentArray);\n    return { fileContents, fileContentArray, errmsg };\n  };\n\n  const generateREADME = async () =\u003e {\n    setLoading(true);\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      return;\n    }\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (!finalPrompt) {\n      setError(\"No content to generate README for.\");\n      setLoading(false);\n      return;\n    }\n\n    if (generatedContent == \"\") {\n      if (autoPullRequest) {\n        console.log(\"Auto pull request enabled.\");\n        const systemInstruction = `You are an API agent. Your response will be consumed directly by code and parsed as a JSON object. Do not format your JSON output in markdown fence blocks. Do not include any explanations. Do not use code fences like \\`\\`\\`json. Just return a raw JSON object.\\nSubmit a pull request for a suggested README file for my code repository ${repository}. You do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        console.log(\n          \"repoFileContentArray before gen ai: \",\n          repoFileContentArray\n        );\n        const genWithToolsResponse =\n          await generateWithSystemInstructionConfigAndTools(\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          );\n\n        console.log(\"genWithToolsResponse: \", genWithToolsResponse);\n        console.log(\"genWithToolsResponse text: \", genWithToolsResponse.text);\n        var pullRequestResult = \"Error submitting pull request\";\n        // this is the built in function call from the api, usually dont work if context is too large\n        if (genWithToolsResponse.functionCalls) {\n          console.log(\"function calls: \", genWithToolsResponse.functionCalls);\n          const tool_call = genWithToolsResponse.functionCalls[0];\n          if (tool_call.name === \"submit_pull_request\" && tool_call.args) {\n            pullRequestResult = await submitPullRequest(\n              tool_call.args.filePath,\n              tool_call.args.commitMessage,\n              tool_call.args.branchName,\n              tool_call.args.pullRequestTitle,\n              tool_call.args.pullRequestBody,\n              tool_call.args.fileContent\n            );\n          }\n        } else {\n          if (genWithToolsResponse.text && genWithToolsResponse.text != \"\") {\n            // try to parse the response as a json object (specified in the system instruction) and call the function\n            try {\n              const parsedResponse: PullRequestArgs = JSON.parse(\n                genWithToolsResponse.text\n              );\n              console.log(\"parsed response: \", parsedResponse);\n              pullRequestResult = await submitPullRequest(\n                parsedResponse.filePath,\n                parsedResponse.commitMessage,\n                parsedResponse.branchName,\n                parsedResponse.pullRequestTitle,\n                parsedResponse.pullRequestBody,\n                parsedResponse.fileContent\n              );\n            } catch (error) {\n              try {\n                // try again after cleaning since the ai keeps wrapping in these tags\n                const cleanJson = genWithToolsResponse.text\n                  .replace(/```json|```$/g, \"\")\n                  .trim();\n                const parsedResponse: PullRequestArgs = JSON.parse(cleanJson);\n                console.log(\"parsed response after cleaning: \", parsedResponse);\n                pullRequestResult = await submitPullRequest(\n                  parsedResponse.filePath,\n                  parsedResponse.commitMessage,\n                  parsedResponse.branchName,\n                  parsedResponse.pullRequestTitle,\n                  parsedResponse.pullRequestBody,\n                  parsedResponse.fileContent\n                );\n                console.log(pullRequestResult);\n                generatedContent =\n                  pullRequestResult + \"\\n\" + genWithToolsResponse.text;\n              } catch (error) {\n                console.error(\"Error parsing response: \", error);\n              }\n            }\n          } else {\n            generatedContent = genWithToolsResponse.text || \"\";\n          }\n        }\n      } else {\n        // if auto pull request is not enabled, just generate the readme and put it on the UI\n        const systemInstruction = `Generate a README for the code repository ${repository}, only return the contents of the README.\\nFormat the README using standard Markdown syntax for text styling. Avoid using code blocks unless displaying code.\\nYou do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        generatedContent =\n          (await generateWithSystemInstructionAndConfig(\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          )) || \"\";\n      }\n\n      cache.set(\"generatedContent\", generatedContent);\n    }\n\n    setOutput(generatedContent);\n    setLoading(false);\n  };\n\n  const generateDocumentation = async () =\u003e {\n    setLoading(true);\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      return;\n    }\n\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      const { fileContents, errmsg } = await fetchFileContents(results);\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n      }\n      repoFileContents = fileContents;\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    if (finalPrompt == \"\") {\n      finalPrompt = `Generate documentation for the repository ${repository} with the following code. For conciseness, you do not need to include the code directly in the documentation, you may chose to include the file path if required. Write the documentation in a way that is easy to understand for a beginner. The documentation should use markdown styling, do not wrap your entire output in markdown tags. The documentation should be split into two sections: how-to guides and reference guides. Try to be detailed for the reference guide. Also include notes for anything the reader should look out for\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    console.log(finalPrompt);\n    if (!finalPrompt) {\n      setError(\"No content to generate documentation for.\");\n      setLoading(false);\n      return;\n    }\n\n    var generatedContent = \"\";\n    if (!cache.has(\"generatedContent\")) {\n      generatedContent =\n        (await generateContentWithConfig(finalPrompt, {\n          temperature: modelTemperature,\n        })) || \"Error generating content\";\n      cache.set(\"generatedContent\", generatedContent);\n    } else {\n      generatedContent = cache.get(\"generatedContent\") || \"\";\n    }\n\n    setOutput(generatedContent);\n    setLoading(false);\n  };\n\n  const submitPullRequest = async (\n    filePath: string,\n    commitMessage: string,\n    branchName: string,\n    pullRequestTitle: string,\n    pullRequestBody: string,\n    fileContent: string\n  ): Promise\u003cstring\u003e =\u003e {\n    console.log(\"Submitting pull request...\");\n    if (fileContent == \"\") {\n      if (output == \"\") {\n        setError(\"No content to submit for pull request.\");\n        return \"No content to submit for pull request.\";\n      }\n      fileContent = output;\n    }\n    if (!filePath || filePath == \"\") {\n      console.log(\"Default file path used as no file path provided.\");\n      setError(\n        \"Default file path used as no file path provided for pull request.\"\n      );\n      filePath = \"README.md\";\n    }\n    if (!commitMessage || commitMessage == \"\") {\n      console.log(\"Default commit message used as no commit message provided.\");\n      setError(\"Default commit message used as no commit message provided.\");\n      commitMessage = \"Generated README from github search saas\";\n    }\n    if (!branchName || branchName == \"\") {\n      console.log(\"Default branch name used as no branch name provided.\");\n      setError(\"Default branch name used as no branch name provided.\");\n      branchName = \"generated-readme\";\n    } else {\n      branchName = branchName.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n      console.log(\"branch name sanitized: \", branchName);\n    }\n    if (!pullRequestTitle || pullRequestTitle == \"\") {\n      console.log(\n        \"Default pull request title used as no pull request title provided.\"\n      );\n      setError(\n        \"Default pull request title used as no pull request title provided.\"\n      );\n      pullRequestTitle = \"Generated README\";\n    }\n    if (!pullRequestBody || pullRequestBody == \"\") {\n      console.log(\n        \"Default pull request body used as no pull request body provided.\"\n      );\n      setError(\n        \"Default pull request body used as no pull request body provided.\"\n      );\n      pullRequestBody = \"This is a generated README from github search saas\";\n    }\n\n    try {\n      // get default branch\n      const defaultBranchResponse = await githubGetCodeApi.get(\n        `/${username}/${repository}`\n      );\n      const defaultBranch = defaultBranchResponse.data.default_branch;\n      console.log(\"default branch of repo: \", defaultBranch);\n\n      // get latest commit and tree\n      const commitAndTreeResponse = await githubGetCodeApi.get(\n        `/${username}/${repository}/branches/${defaultBranch}`\n      );\n      const oldCommit = commitAndTreeResponse.data.commit.sha;\n      const oldTree = commitAndTreeResponse.data.commit.commit.tree.sha;\n      console.log(\"previous commit and tree: \", oldCommit, oldTree);\n\n      // create new tree with new file\n      const newTreeResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/git/trees`,\n        {\n          base_tree: oldTree,\n          tree: [\n            {\n              path: filePath,\n              mode: \"100644\",\n              type: \"blob\",\n              content: fileContent,\n            },\n          ],\n        }\n      );\n      const newTree = newTreeResponse.data.sha;\n\n      // create new commit object\n      const newCommitResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/git/commits`,\n        {\n          message: commitMessage,\n          tree: newTree,\n          parents: [oldCommit],\n        }\n      );\n      const newCommit = newCommitResponse.data.sha;\n      console.log(\"new commit: \", newCommit);\n\n      // create new reference (branch) for the commit;\n      const newBranchName = branchName + Date.now();\n      const newReferenceResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/git/refs`,\n        {\n          ref: `refs/heads/${newBranchName}`,\n          sha: newCommit,\n        }\n      );\n      console.log(\"new reference: \", newReferenceResponse);\n\n      //  '{\"title\":\"Amazing new feature\",\"body\":\"Please pull these awesome changes in!\",\"head\":\"octocat:new-feature\",\"base\":\"master\"}'\n      // create pull request\n      const pullRequestResponse = await githubGetCodeApi.post(\n        `/${username}/${repository}/pulls`,\n        {\n          title: pullRequestTitle,\n          body: pullRequestBody,\n          head: newBranchName,\n          base: defaultBranch,\n        }\n      );\n      console.log(\"pull request response: \", pullRequestResponse);\n      return \"Pull request submitted successfully!\";\n    } catch (error) {\n      console.error(\"Error submitting pull request: \", error);\n      return \"Error submitting pull request: \" + error;\n    }\n  };\n\n  return (\n    \u003cdiv className=\"p-4 border-gray-500 border-2 rounded-lg flex-grow\"\u003e\n      \u003cdiv className=\"flex flex-col gap-4 items-start\"\u003e\n        \u003ch2 className=\"text-2xl\"\u003eExtra functions\u003c/h2\u003e\n        \u003cdiv className=\"flex gap-4 w-full\"\u003e\n          \u003cp className=\"text-lg text-nowrap\"\u003e\n            Model Temperature (how much variation in the output):\n          \u003c/p\u003e\n          \u003cdiv className=\"w-1/3\"\u003e\n            \u003cSlider\n              aria-label=\"Temperature\"\n              size=\"small\"\n              defaultValue={0}\n              min={0}\n              max={1}\n              step={0.1}\n              marks\n              valueLabelDisplay=\"auto\"\n              onChange={(_, value) =\u003e {\n                setModelTemperature(value.valueOf() as number);\n              }}\n            /\u003e\n          \u003c/div\u003e\n          \u003cp\u003e{modelTemperature}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003ch3 className=\"text-lg\"\u003eSelected Details:\u003c/h3\u003e\n        \u003cp\u003eUsername: {username || \"None selected\"}\u003c/p\u003e\n        \u003cdiv\u003e\n          \u003cdiv className=\"flex gap-4 items-center mb-2\"\u003e\n            \u003cp\u003eRepository: {repository || \"None selected\"}\u003c/p\u003e\n            \u003cp\u003eProcessing Cache (makes the buttons below faster):\u003c/p\u003e\n            {cache.has(\"repoFileContents\") ? (\n              \u003cp className=\"text-green-500\"\u003e\n                Repository File Contents Cached {repoFileContentArray.length}\n              \u003c/p\u003e\n            ) : (\n              \u003cp className=\"text-red-500 font-bold\"\u003e\n                Repository File Contents not Cached\n              \u003c/p\u003e\n            )}\n            {cache.has(\"generatedContent\") ? (\n              \u003cp className=\"text-green-500\"\u003eAI Output Cached\u003c/p\u003e\n            ) : (\n              \u003cp className=\"text-red-500 font-bold\"\u003eAI Output not Cached\u003c/p\u003e\n            )}\n          \u003c/div\u003e\n          \u003cdiv className=\"flex gap-4 items-center mb-2\"\u003e\n            \u003cp\u003eAuto Submit Pull Request?\u003c/p\u003e\n            \u003cinput\n              type=\"checkbox\"\n              checked={autoPullRequest}\n              onChange={(e) =\u003e setAutoPullRequest(e.target.checked)}\n            /\u003e\n          \u003c/div\u003e\n          \u003cdiv className=\"flex gap-4\"\u003e\n            \u003cbutton onClick={generateDocumentation}\u003e\n              Generate Documentation\n            \u003c/button\u003e\n            \u003cbutton onClick={generateREADME}\u003eGenerate README\u003c/button\u003e\n            \u003cbutton onClick={clearRepoContent}\u003eClear File Content cache\u003c/button\u003e\n            \u003cbutton onClick={clearGenContent}\u003eClear AI output cache\u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cp\u003e\n          Items:{\" \"}\n          {selectedItems && selectedItems.length \u003e 0\n            ? results\n                .filter((item) =\u003e selectedItems.includes(item.sha))\n                .map((item) =\u003e `${item.name} (${item.repository.full_name})`)\n                .join(\", \")\n            : \"None selected\"}\n        \u003c/p\u003e\n        {loading && \u003cp\u003eLoading...\u003c/p\u003e}\n        {error && \u003cp className=\"text-red-500\"\u003e{error}\u003c/p\u003e}\n\n        \u003cdiv className=\"w-full\"\u003e\n          \u003cdiv className=\"flex gap-4 items-center mb-2\"\u003e\n            \u003cp\u003eOutput\u003c/p\u003e\n            \u003cbutton\n              onClick={() =\u003e\n                downloadOutput(output, \"text/markdown\", \"output.md\")\n              }\n              disabled={!output}\n              className=\"!p-2\"\n            \u003e\n              Download Output\n            \u003c/button\u003e\n            \u003cbutton\n              onClick={() =\u003e\n                downloadOutput(\n                  cache.get(\"repoFileContents\") || \"\",\n                  \"text/plain\",\n                  \"Repository_File_Contents.txt\"\n                )\n              }\n              disabled={!cache.has(\"repoFileContents\")}\n              className=\"!p-2\"\n            \u003e\n              Download File Contents\n            \u003c/button\u003e\n            \u003cbutton\n              onClick={() =\u003e\n                submitPullRequest(\n                  \"README.md\",\n                  \"Generated README from github search saas\",\n                  \"generated-readme\",\n                  \"Generated README\",\n                  \"This is a generated README from github search saas\",\n                  output\n                )\n              }\n              className=\"!bg-green-800 !p-2\"\n            \u003e\n              Submit Pull Request with the output below\n            \u003c/button\u003e\n          \u003c/div\u003e\n          \u003ctextarea\n            className=\"w-full h-64 border-gray-500 border-2 rounded-lg p-2\"\n            placeholder=\"Generated documentation will appear here...\"\n            value={output}\n            onChange={(e) =\u003e setOutput(e.target.value)}\n          \u003e\u003c/textarea\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default CodeEdit;\n```\n\n**Updated Comments**\n```typescript\nimport React, { useState, useEffect } from \"react\";\nimport { useGithubContext } from \"../context/useGithubContext\";\nimport { githubGetCodeApi } from \"../api/apiconfigs\";\nimport {\n  defaultGenerationConfig,\n  generateContentWithConfig,\n  generateWithSystemInstructionAndConfig,\n  generateWithSystemInstructionConfigAndTools,\n  generateWithTools,\n  PullRequestArgs,\n} from \"../geminiAPI/geminiAPI\";\nimport { Slider } from \"@mui/material\";\n\nconst CodeEdit: React.FC = () =\u003e {\n  const {\n    username,\n    repository,\n    selectedItems,\n    results,\n    cache,\n    setCache,\n    repoFileContentArray,\n    setRepoFileContentArray,\n  } = useGithubContext();\n\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState\u003cstring | null\u003e(null);\n  const [output, setOutput] = useState\u003cstring\u003e(\n    cache.get(\"generatedContent\") || \"\"\n  );\n  const [modelTemperature, setModelTemperature] = useState\u003cnumber\u003e(0);\n  const [autoPullRequest, setAutoPullRequest] = useState\u003cboolean\u003e(false);\n\n  const clearGenContent = () =\u003e {\n    // Clear the generated content and final prompt from the cache.\n    cache.delete(\"generatedContent\");\n    cache.delete(\"finalPrompt\");\n    setOutput(\"\");\n    console.log(\"Cache size: \", cache.size);\n  };\n  const clearRepoContent = () =\u003e {\n    // Clear the repository file contents from the cache.\n    cache.delete(\"repoFileContents\");\n    setRepoFileContentArray([]);\n    setOutput(\"\");\n    console.log(\"Cache: \", cache);\n  };\n\n  const downloadOutput = (\n    content: string,\n    filetype: string,\n    filename: string\n  ) =\u003e {\n    // Downloads the given content as a file.\n    const blob = new Blob([content], { type: filetype });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = filename;\n    link.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const validateInitialState = (): boolean =\u003e {\n    // Validates that a repository is selected and that search results exist.\n    if (!repository) {\n      setError(\"No repository selected. Please select a repo first.\");\n      return false;\n    }\n    if (results && results.length == 0) {\n      setError(\n        \"No results found. Please attempt a search to see what is in your repo first.\"\n      );\n      return false;\n    }\n    return true;\n  };\n\n  const checkCache = (): {\n    repoFileContents: string;\n    finalPrompt: string;\n    generatedContent: string;\n  } =\u003e {\n    // Retrieves cached values for repoFileContents, finalPrompt, and generatedContent.\n    return {\n      repoFileContents: cache.get(\"repoFileContents\") || \"\",\n      finalPrompt: cache.get(\"finalPrompt\") || \"\",\n      generatedContent: cache.get(\"generatedContent\") || \"\",\n    };\n  };\n\n  const fetchFileContents = async (\n    items: any[]\n  ): Promise\u003c{\n    fileContents: string;\n    fileContentArray: string[];\n    errmsg: string;\n  }\u003e =\u003e {\n    // Fetches the content of each file in the results from GitHub.\n    var fileContents = \"\";\n    var fileContentArray: string[] = [];\n    var errmsg = \"\";\n    for (const item of results) {\n      try {\n        const response = await githubGetCodeApi.get(\n          `/${item.repository.full_name}/contents/${item.path}`\n        );\n        const fileContent = atob(response.data.content);\n        fileContents += item.path + \"\\n\" + fileContent + \"\\n\\n\";\n        fileContentArray.push(item.path + \"\\n\" + fileContent);\n      } catch (error) {\n        console.error(`Error fetching file content for ${item.path}: ${error}`);\n        errmsg += item.path + \"; \";\n      }\n    }\n\n    console.log(\"fileContentArray fetched: \", fileContentArray);\n    return { fileContents, fileContentArray, errmsg };\n  };\n\n  const generateREADME = async () =\u003e {\n    setLoading(true);\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      return;\n    }\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      let { fileContents, fileContentArray, errmsg } = await fetchFileContents(\n        results\n      );\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n      }\n      console.log(\"promptArray reset: \", fileContentArray);\n      repoFileContents = fileContents;\n      await setRepoFileContentArray(fileContentArray);\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    console.log(\"repoFileContentArray after reset: \", repoFileContentArray);\n    if (finalPrompt == \"\") {\n      finalPrompt = `These are the contents of the files in the repository\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    if (!finalPrompt) {\n      setError(\"No content to generate README for.\");\n      setLoading(false);\n      return;\n    }\n\n    if (generatedContent == \"\") {\n      if (autoPullRequest) {\n        console.log(\"Auto pull request enabled.\");\n        const systemInstruction = `You are an API agent. Your response will be consumed directly by code and parsed as a JSON object. Do not format your JSON output in markdown fence blocks. Do not include any explanations. Do not use code fences like \\`\\`\\`json. Just return a raw JSON object.\\nSubmit a pull request for a suggested README file for my code repository ${repository}. You do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        console.log(\n          \"repoFileContentArray before gen ai: \",\n          repoFileContentArray\n        );\n        const genWithToolsResponse =\n          await generateWithSystemInstructionConfigAndTools(\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          );\n\n        console.log(\"genWithToolsResponse: \", genWithToolsResponse);\n        console.log(\"genWithToolsResponse text: \", genWithToolsResponse.text);\n        var pullRequestResult = \"Error submitting pull request\";\n        // This section attempts to submit a pull request automatically using the Gemini API with function calling.\n        if (genWithToolsResponse.functionCalls) {\n          console.log(\"function calls: \", genWithToolsResponse.functionCalls);\n          const tool_call = genWithToolsResponse.functionCalls[0];\n          if (tool_call.name === \"submit_pull_request\" && tool_call.args) {\n            pullRequestResult = await submitPullRequest(\n              tool_call.args.filePath,\n              tool_call.args.commitMessage,\n              tool_call.args.branchName,\n              tool_call.args.pullRequestTitle,\n              tool_call.args.pullRequestBody,\n              tool_call.args.fileContent\n            );\n          }\n        } else {\n          if (genWithToolsResponse.text && genWithToolsResponse.text != \"\") {\n            // If no function call is returned, try to parse the response as a JSON object (specified in the system instruction) and call the function manually.\n            try {\n              const parsedResponse: PullRequestArgs = JSON.parse(\n                genWithToolsResponse.text\n              );\n              console.log(\"parsed response: \", parsedResponse);\n              pullRequestResult = await submitPullRequest(\n                parsedResponse.filePath,\n                parsedResponse.commitMessage,\n                parsedResponse.branchName,\n                parsedResponse.pullRequestTitle,\n                parsedResponse.pullRequestBody,\n                parsedResponse.fileContent\n              );\n            } catch (error) {\n              try {\n                // Try again after cleaning since the AI keeps wrapping the JSON in markdown tags.\n                const cleanJson = genWithToolsResponse.text\n                  .replace(/```json|```$/g, \"\")\n                  .trim();\n                const parsedResponse: PullRequestArgs = JSON.parse(cleanJson);\n                console.log(\"parsed response after cleaning: \", parsedResponse);\n                pullRequestResult = await submitPullRequest(\n                  parsedResponse.filePath,\n                  parsedResponse.commitMessage,\n                  parsedResponse.branchName,\n                  parsedResponse.pullRequestTitle,\n                  parsedResponse.pullRequestBody,\n                  parsedResponse.fileContent\n                );\n                console.log(pullRequestResult);\n                generatedContent =\n                  pullRequestResult + \"\\n\" + genWithToolsResponse.text;\n              } catch (error) {\n                console.error(\"Error parsing response: \", error);\n              }\n            }\n          } else {\n            generatedContent = genWithToolsResponse.text || \"\";\n          }\n        }\n      } else {\n        // If auto pull request is not enabled, just generate the readme and put it on the UI\n        const systemInstruction = `Generate a README for the code repository ${repository}, only return the contents of the README.\\nFormat the README using standard Markdown syntax for text styling. Avoid using code blocks unless displaying code.\\nYou do not need to include the code directly in the README, you may chose to include the file path if required.\\nWrite the README in a way that is easy to understand for a beginner.\\nInclude a short description of what the repository contains, an overview of the code, architecture (if applicable) and how to set up and use it.\\nAlso include brief notes that the reader should look out for when using the repository such as not commiting their env file.`;\n\n        generatedContent =\n          (await generateWithSystemInstructionAndConfig(\n            systemInstruction,\n            finalPrompt,\n            {\n              temperature: modelTemperature,\n            }\n          )) || \"\";\n      }\n\n      cache.set(\"generatedContent\", generatedContent);\n    }\n\n    setOutput(generatedContent);\n    setLoading(false);\n  };\n\n  const generateDocumentation = async () =\u003e {\n    setLoading(true);\n    setError(null);\n    if (!validateInitialState()) {\n      setLoading(false);\n      return;\n    }\n\n    var { repoFileContents, finalPrompt, generatedContent } = checkCache();\n\n    if (repoFileContents == \"\") {\n      const { fileContents, errmsg } = await fetchFileContents(results);\n      if (errmsg) {\n        setError(\"Error fetching file content for: \" + errmsg);\n      }\n      repoFileContents = fileContents;\n      cache.set(\"repoFileContents\", repoFileContents);\n    }\n\n    if (finalPrompt == \"\") {\n      finalPrompt = `Generate documentation for the repository ${repository} with the following code. For conciseness, you do not need to include the code directly in the documentation, you may chose to include the file path if required. Write the documentation in a way that is easy to understand for a beginner. The documentation should use markdown styling, do not wrap your entire output in markdown tags. The documentation should be split into two sections: how-to guides and reference guides. Try to be detailed for the reference guide. Also include notes for anything the reader should look out for\\n\\n${repoFileContents}`;\n      cache.set(\"finalPrompt\", finalPrompt);\n    }\n\n    console.log(finalPrompt);\n    if (!finalPrompt) {\n      setError(\"No content to generate documentation for.\");\n      setLoading(false);\n      return;\n    }\n\n    var generatedContent = \"\";\n    if (!cache.has(\"generatedContent\")) {\n      generatedContent =\n        (await generateContentWithConfig(finalPrompt, {\n          temperature: modelTemperature,\n        })) || \"Error generating content\";\n      cache.set(\"generatedContent\", generatedContent);\n    } else {\n      generatedContent = cache.get(\"generatedContent\") || \"\";\n    }\n\n    setOutput(generatedContent);\n    setLoading(false);\n  };\n\n  const submitPullRequest = async (\n    filePath: string,\n    commitMessage: string,\n    branchName: string,\n    pullRequestTitle: string,\n    pullRequestBody: string,\n    fileContent: string\n  ): Promise\u003cstring\u003e =\u003e {\n    // Submits a pull request to the GitHub repository.\n    console.log(\"Submitting pull request...\");\n    if (fileContent == \"\") {\n      if (output == \"\") {\n        setError(\"No content to submit for pull request.\");\n        return \"No content to submit for pull request.\";\n      }\n      fileContent = output;\n    }\n    if (!filePath || filePath == \"\") {\n      console.log(\"Default file path used as no file path provided.\");\n      setError(\n        \"Default file path used as no file path provided for pull request.\"\n      );\n      filePath = \"README.md\";\n    }\n    if (!commitMessage || commitMessage == \"\") {\n      console.log(\"Default commit message used as no commit message provided.\");\n      setError(\"Default commit message used as no commit message provided.\");\n      commitMessage = \""
                    }
                ],
                "role": "model"
            },
            "finishReason": "MAX_TOKENS",
            "citationMetadata": {
                "citationSources": [
                    {
                        "startIndex": 1714,
                        "endIndex": 1886,
                        "uri": "https://github.com/christero/OrganizationLookup"
                    },
                    {
                        "startIndex": 1772,
                        "endIndex": 1945,
                        "uri": "https://stackoverflow.com/questions/77485961/how-can-i-display-a-pdf-using-a-graphql-query-and-react"
                    },
                    {
                        "startIndex": 22608,
                        "endIndex": 22780,
                        "uri": "https://github.com/christero/OrganizationLookup"
                    },
                    {
                        "startIndex": 22666,
                        "endIndex": 22839,
                        "uri": "https://stackoverflow.com/questions/77485961/how-can-i-display-a-pdf-using-a-graphql-query-and-react"
                    }
                ]
            },
            "avgLogprobs": -0.0083815804642258934
        }
    ],
    "usageMetadata": {
        "promptTokenCount": 82702,
        "candidatesTokenCount": 8181,
        "totalTokenCount": 90883,
        "promptTokensDetails": [
            {
                "modality": "TEXT",
                "tokenCount": 82702
            }
        ],
        "candidatesTokensDetails": [
            {
                "modality": "TEXT",
                "tokenCount": 8181
            }
        ]
    },
    "modelVersion": "gemini-2.0-flash"
}